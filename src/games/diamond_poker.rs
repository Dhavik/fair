//! # provably fair diamond poker
//!

/*
  When playing Diamond Poker, there is 7 possible outcomes in the form of gems. To achieve this,
  we multiply each float generated by 7 before it is translated into a corresponding gem using
  the following index:

  // Index of 0 to 6 : green to blue
  const GEMS = [ green, purple, yellow, red, cyan, orange, blue ];

  // Game event translation
  const gem = GEMS[Math.floor(float * 7)];

  Both the dealer and the player are dealt 5 gems each, which means that a complete game of
  Diamond Poker requires the generation of 10 game events. The first 5 are assigned to the dealer
  and the second 5 are assigned to the player.
*/

pub use crate::rng::ProvablyFairRNG;
use std::fmt;

static GEM_ORDER: [Gem; 7] = [Green, Purple, Yellow, Red, Cyan, Orange, Blue];

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Gem {
    Green,
    Purple,
    Yellow,
    Red,
    Cyan,
    Orange,
    Blue,
}

#[derive(Debug, PartialEq)]
pub enum Outcome {
    PlayerWin,
    DealerWin,
    Tie,
}

use Gem::*;

#[derive(Debug)]
pub struct Hand {
    gems: Vec<Gem>,
}

impl Hand {
    fn new() -> Hand {
        Hand {
            gems: Vec::with_capacity(5),
        }
    }
    fn analyze(&self) {}
}

impl fmt::Display for Hand {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // write!(f, "dealer: {}\nplayer: {}", self.dealer, self.player)
        write!(f, "{:?}", self.gems)
    }
}

#[derive(Debug)]
pub struct SimulationResult {
    pub dealer: Hand,
    pub player: Hand,
    // pub outcome: Outcome
    // pub winner: Winner,
}

impl fmt::Display for SimulationResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // write!(f, "dealer: {}\nplayer: {}", self.dealer, self.player)
        write!(f, "Dealer: {}\nPlayer: {}", self.dealer, self.player)
    }
}

// TODO: refactor player/dealer arrays into a Hand struct which implements partial eq? so we can do
// let winner = match cmp::sasldfjasf(playerHand, dealerHand) { case cmp::Greater => Winner::Player
// ...} etc.
/*
fn evaluate_hand(hand: &[Gem; 5]) -> u32 {
    // give a score to a hand...
}
*/

fn draw_hand(rng: &mut ProvablyFairRNG<f64>) -> Hand {
    let mut hand = Hand::new();
    for _ in 0..5 {
        let idx = (rng.next().unwrap() * 7.) as usize;
        hand.gems.push(GEM_ORDER[idx]);
    }
    hand
}

/// Simulates a game of diamond poker.
///
/// # Example
///
/// ```
///
/// let client_seed = "some client seed";
/// let server_seed = "some server seed";
/// let nonce = 1;
/// let result = fair::games::diamond_poker::simulate(
///   client_seed,
///   server_seed,
///   nonce,
/// );
/// ```
///
pub fn simulate(client_seed: &str, server_seed: &str, nonce: u64) -> SimulationResult {
    let mut rng: ProvablyFairRNG<f64> = ProvablyFairRNG::new(client_seed, server_seed, nonce);

    let dealer = draw_hand(&mut rng);
    let player = draw_hand(&mut rng);

    // let winner = evaluate_winner(dealer, player);

    // let outcome = (rng.next().unwrap() * 10001.) as u32;
    // let outcome = outcome as f64 / 100.;
    SimulationResult {
        dealer,
        player,
        // winner,
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn simulate_dice_roll() {
        let client_seed = "client seed";
        let server_seed = "server seed";
        let nonce = 1;
        let result = simulate(client_seed, server_seed, nonce);
        // println!("{:?}", result);
        assert_eq!(result.dealer, [Orange, Cyan, Purple, Blue, Red]);
        assert_eq!(result.player, [Blue, Cyan, Cyan, Blue, Green]);
        // assert_eq!(result.winner, Winner::Player);
        let nonce = 2;
        let result = simulate(client_seed, server_seed, nonce);
        // println!("{:?}", result);
        // assert_eq!(result.outcome, 53.86);
    }
}
